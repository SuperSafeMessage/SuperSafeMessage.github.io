<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Super Safe Message</title>
</head>

<body>
    <a href="/">English</a>

    <a href="/zh_cn.html">中文</a>

    <h1>Super Safe Message</h1>
    <h5>World's Safest Way to Share Message</h5>

    <div class="receiver-panel">
        <a id="share-link" href="" target="_blank">Wait...</a>
        <p>Share the above link and wait for messages</p>
        <p>Don't close/refresh this page, or you will never be able to receive messages from the above link again.</p>
        <button id="refresh-btn">Refresh Received Messages</button>
        <h2>Received Messages:</h2>
        <p id="receive-status"></p>
        <div id="messages"></div>
    </div>
    <div class="sender-panel">
        <input type="text" />
        <button id="send-btn">Send</button>
        <p id="send-status"></p>
    </div>
    <div>
        <br>
        <hr>
        <h2>Safe Tips</h2>
        <p>1. Use a clean and updated system, along with the latest browser, and avoid installing any third-party
            certificates.
        </p>


        <p>2. Turn off all browser extensions, open the browser in private or incognito mode, read the messages,
            remember
            them,
            and then close the browser without saving any information on your device.</p>

        <p>3. Make sure to confirm that your recipients and senders are who they say they are, and double-check that the
            links
            you share haven't been tampered with. (This step may not be needed for most people.</p>
    </div>
    </div>

    <style>
        .receiver-panel,
        .sender-panel {
            display: none;
        }
    </style>

    <script>
        const host = "https://summer-salad-6492.maggch.workers.dev/"

        async function receive(receiver) {
            const api = new URL(host + "receive");
            api.searchParams.set("receiver", receiver);
            return fetch(api);
        }

        async function send(receiver, message) {
            const api = new URL(host + "send");
            api.searchParams.set("receiver", receiver);
            api.searchParams.set("message", message);
            return (await fetch(api));
        }

        // Generate RSA key pair
        async function generateRSAKeyPair() {
            const { publicKey, privateKey } = await window.crypto.subtle.generateKey(
                {
                    name: 'RSA-OAEP',
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: { name: 'SHA-256' },
                },
                true,
                ['encrypt', 'decrypt']
            );
            return { publicKey, privateKey };
        }

        async function publicKeyToBase64(publicKey) {
            const exportedPublicKey = await window.crypto.subtle.exportKey(
                'spki',
                publicKey
            );
            return arrayBufferToBase64(exportedPublicKey);
        }

        async function importRSAKeyPair(publicKeyBase64) {
            let publicKey;
            // Convert the Base64-encoded public key to a binary format
            const publicKeyBinary = atob(publicKeyBase64);

            // Convert the binary data to an ArrayBuffer
            const publicKeyBuffer = new ArrayBuffer(publicKeyBinary.length);
            const publicKeyArray = new Uint8Array(publicKeyBuffer);
            for (let i = 0; i < publicKeyBinary.length; i++) {
                publicKeyArray[i] = publicKeyBinary.charCodeAt(i);
            }

            // Import the public key using SubtleCrypto.importKey
            publicKey = await window.crypto.subtle.importKey(
                'spki',
                publicKeyBuffer,
                {
                    name: 'RSA-OAEP',
                    hash: { name: 'SHA-256' },
                },
                true,
                ['encrypt']
            );

            return publicKey
        }

        // Convert an ArrayBuffer to a Base64 string
        function arrayBufferToBase64(buffer) {
            const binary = String.fromCharCode(...new Uint8Array(buffer));
            return btoa(binary);
        }

        // Convert an ArrayBuffer to a string
        function arrayBufferToString(buffer) {
            const decoder = new TextDecoder();
            return decoder.decode(buffer);
        }

        // Convert a string to an ArrayBuffer
        function stringToArrayBuffer(str) {
            const encoder = new TextEncoder();
            return encoder.encode(str);
        }

        // Convert a Base64 string to an ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const buffer = new ArrayBuffer(binary.length);
            const bufferView = new Uint8Array(buffer);
            for (let i = 0; i < binary.length; i++) {
                bufferView[i] = binary.charCodeAt(i);
            }
            return buffer;
        }

        // Encrypt a string using RSA-OAEP with the public key and return the result as a Base64 string
        async function encryptWithPublicKey(publicKey, plaintext) {
            const encodedPlaintext = stringToArrayBuffer(plaintext);
            const encrypted = await window.crypto.subtle.encrypt(
                {
                    name: 'RSA-OAEP',
                },
                publicKey,
                encodedPlaintext
            );
            const encryptedBase64 = arrayBufferToBase64(encrypted);
            return encryptedBase64;
        }

        // Decrypt a Base64 string using RSA-OAEP with the private key and return the result as a string
        async function decryptWithPrivateKey(privateKey, ciphertextBase64) {
            const ciphertext = base64ToArrayBuffer(ciphertextBase64);
            const decrypted = await window.crypto.subtle.decrypt(
                {
                    name: 'RSA-OAEP',
                },
                privateKey,
                ciphertext
            );
            const decryptedString = arrayBufferToString(decrypted);
            return decryptedString;
        }


        (async () => {
            const url = new URL(window.location.href)
            const receiver = url.searchParams.get("receiver");
            let isSender = false;
            if (receiver) {
                isSender = true;
            }

            if (isSender) {
                document.querySelector('.sender-panel').style.display = "block"
                let publicKey = await importRSAKeyPair(receiver);
                document.querySelector('#send-btn').onclick = async () => {
                    document.querySelector("#send-status").innerHTML = "Sending..."
                    try {
                        if (await (await send(receiver, await encryptWithPublicKey(publicKey, document.querySelector("input").value))).text() == 'ok') {
                            document.querySelector("#send-status").innerHTML = "Success"
                        } else {
                            document.querySelector("#send-status").innerHTML = "Error"
                        }
                    } catch (e) {
                        document.querySelector("#send-status").innerHTML = "Failed"
                    }
                }

            } else {
                document.querySelector('.receiver-panel').style.display = "block"
                const { publicKey, privateKey } = await generateRSAKeyPair();
                let receiver = await publicKeyToBase64(publicKey);

                const link = new URL(window.location.href);
                link.searchParams.set("receiver", receiver);
                document.querySelector('#share-link').href = link;
                document.querySelector('#share-link').innerHTML = link;
                const refresh = async () => {
                    document.querySelector("#messages").innerHTML = ""
                    document.querySelector('#receive-status').innerText = "Receiving...";
                    let messages;
                    try {
                        messages = await (await receive(receiver)).json();
                        document.querySelector('#receive-status').innerText = "";
                    } catch (e) {
                        document.querySelector('#receive-status').innerText = "Failed to receive messages.";
                        return;
                    }
                    messages.forEach(async msg => {
                        let p = document.createElement('p');
                        p.innerText = await decryptWithPrivateKey(privateKey, msg);
                        document.querySelector("#messages").appendChild(p);
                    });
                };
                setInterval(refresh, 60000);
                document.querySelector("#refresh-btn").onclick = refresh;
            }
        })();
    </script>
</body>

</html>